
# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT")
if _target and os.path.isdir(_target):
    if _target not in sys.path: sys.path.insert(0, _target)

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

# Optional Django bootstrap to avoid masking real failures by default.
if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

import os
os.environ.setdefault('QT_QPA_PLATFORM', 'offscreen')
for __qt_root in ['PyQt5','PyQt6','PySide2','PySide6']:
    try:
        import importlib.util as _iu
        if _iu.find_spec(__qt_root) is None:
            raise ImportError
    except Exception:
        pass
# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

import builtins
import inspect
import math
from unittest import mock

import pytest

# Guard third-party imports
try:
    from PyQt5 import QtWidgets
    from PyQt5.QtWidgets import QFileDialog
except ImportError:
    pytest.skip("PyQt5 is required for these integration tests", allow_module_level=True)

# Import application modules under test
import Calculator
import SimpleCalculatorPyQt1

# Helper to obtain add/subtract callable (top-level or bound to Calculator instance)
def _get_binary_op(module, name):
    """
    Return a callable that accepts two arguments (a, b) performing the operation.
    Looks for a top-level function first, then a Calculator class method.
    """
    fn = getattr(module, name, None)
    if callable(fn):
        return fn

    CalcClass = getattr(module, "Calculator", None)
    if CalcClass is None:
        raise AssertionError(f"No top-level {name} and no Calculator class in module {module!r}")

    instance = CalcClass()
    method = getattr(instance, name, None)
    if callable(method):
        return method

    raise AssertionError(f"No callable {name} found as top-level or on Calculator instance in {module!r}")


@pytest.mark.parametrize(
    "a,b,expected",
    [
        (1, 2, 3),              # normal integers
        (0, 0, 0),              # zeros
        (-5, 3, -2),            # negatives
        (2.5, 1.25, 3.75),      # floats
    ],
)
def test_add_and_subtract_produce_expected_results(a, b, expected):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: obtain add and subtract callables from Calculator module
    add = _get_binary_op(Calculator, "add")
    subtract = _get_binary_op(Calculator, "subtract")

    # Act: perform operations
    add_result = add(a, b)
    sub_result = subtract(add_result, b)

    # Assert: types and concrete values
    assert isinstance(add_result, (int, float)), "add should return a numeric type"
    # Use isclose for floats, exact equality for ints
    if isinstance(expected, float) or isinstance(add_result, float):
        assert math.isclose(add_result, expected, rel_tol=1e-9, abs_tol=1e-12)
    else:
        assert add_result == expected

    # Subtracting b should return original a
    if isinstance(a, float) or isinstance(sub_result, float):
        assert math.isclose(sub_result, a, rel_tol=1e-9, abs_tol=1e-12)
    else:
        assert sub_result == a


@pytest.mark.parametrize(
    "bad_inputs",
    [
        ("a", "b"),             # strings
        (None, 1),              # None with number
    ],
)
def test_add_raises_on_invalid_types(bad_inputs):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    add = _get_binary_op(Calculator, "add")
    # Determine expected exception: prefer a CalculatorError if available
    expected_exc = getattr(Calculator, "CalculatorError", TypeError)

    # Act / Assert
    with pytest.raises(expected_exc):
        add(*bad_inputs)


def _collect_history_from_operations(module, ops):
    """
    Run a sequence of binary operations described by ops list of tuples
    (op_name, a, b) and return list of string representations of results.
    This supports top-level functions or Calculator instance methods.
    """
    results = []
    for op_name, a, b in ops:
        op = _get_binary_op(module, op_name)
        res = op(a, b)
        results.append(res)
    # Normalize to strings for writing and checking
    return [str(r) for r in results]


def test_save_history_integration_with_mainwindow(tmp_path, monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    # Build a small operation history using Calculator add/subtract
    ops = [("add", 1, 2), ("subtract", 5, 3), ("add", 2.5, 0.5)]
    history_lines = _collect_history_from_operations(Calculator, ops)

    # Prepare target filename
    target_file = tmp_path / "calc_history.txt"

    # Ensure a QApplication exists for MainWindow instantiation
    app = QtWidgets.QApplication.instance()
    if app is None:
        app = QtWidgets.QApplication([])

    # Instantiate MainWindow if available, else use save_history function if present
    MainWindow = getattr(SimpleCalculatorPyQt1, "MainWindow", None)
    save_history_fn = getattr(SimpleCalculatorPyQt1, "save_history", None)

    # Monkeypatch file dialog to return our target_file path
    monkeypatch.setattr(QFileDialog, "getSaveFileName", staticmethod(lambda *args, **kwargs: (str(target_file), "")))

    # Act
    if MainWindow is not None:
        mw = MainWindow()
        # Try to find a save_history method on the instance first
        if hasattr(mw, "save_history") and callable(mw.save_history):
            # Prepare the window's history state if possible
            if hasattr(mw, "history"):
                mw.history = history_lines
            else:
                # If there's no history attribute, try to set a display text if exists
                if hasattr(mw, "history_list") and hasattr(mw.history_list, "clear"):
                    # best effort; not required for assertion below
                    pass
            # Call instance method which should trigger file writing
            mw.save_history()
        elif callable(save_history_fn):
            # Call module-level save_history with our history
            save_history_fn(history_lines)
        else:
            pytest.skip("No save_history or MainWindow.save_history available in SimpleCalculatorPyQt1")
    else:
        if callable(save_history_fn):
            save_history_fn(history_lines)
        else:
            pytest.skip("No MainWindow class and no save_history function found; cannot run GUI save integration")

    # Assert: file written and contains expected entries
    assert target_file.exists(), "Expected history file to be created"
    content = target_file.read_text(encoding="utf-8")
    for item in history_lines:
        assert item in content, f"Expected history item {item!r} to appear in saved file"


def test_save_history_handles_file_write_errors(monkeypatch, tmp_path):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: prepare a small history list
    history_lines = ["1", "2", "3"]
    save_history_fn = getattr(SimpleCalculatorPyQt1, "save_history", None)
    MainWindow = getattr(SimpleCalculatorPyQt1, "MainWindow", None)

    # Simulate file open/write raising an OSError
    def fake_open(*args, **kwargs):
        raise OSError("disk full or permission denied")

    monkeypatch.setattr(builtins, "open", fake_open)

    expected_exc_type = getattr(SimpleCalculatorPyQt1, "CalculatorError", OSError)

    # Act / Assert: depending on available API, ensure appropriate exception is raised
    if MainWindow is not None:
        app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])
        mw = MainWindow()
        if hasattr(mw, "save_history") and callable(mw.save_history):
            with pytest.raises(expected_exc_type):
                mw.save_history()
            return
    if callable(save_history_fn):
        with pytest.raises(expected_exc_type):
            save_history_fn(history_lines)
        return

    pytest.skip("No save_history or MainWindow.save_history available in SimpleCalculatorPyQt1 to test error handling")
