
# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]  # behave like a namespace package
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

# Optional Django bootstrap to avoid masking real failures by default.
if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

import os
os.environ.setdefault('QT_QPA_PLATFORM', 'offscreen')
for __qt_root in ['PyQt5','PyQt6','PySide2','PySide6']:
    try:
        import importlib.util as _iu
        if _iu.find_spec(__qt_root) is None:
            raise ImportError
    except Exception:
        pass
# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

try:
    from PyQt5 import QtWidgets, QtGui  # guard third-party import
except ImportError:
    import pytest
    pytest.skip("PyQt5 is required for these tests", allow_module_level=True)

import importlib
import builtins
import os
import io
import types
import pytest
from unittest import mock

# Import target modules with fallback names
def _import_fallback(*names):
    last_exc = None
    for name in names:
        try:
            return importlib.import_module(name)
        except Exception as e:
            last_exc = e
    raise last_exc

calc_mod = _import_fallback('Calculator', 'target.Calculator')
gui_mod = _import_fallback('SimpleCalculatorPyQt1', 'target.SimpleCalculatorPyQt1')

Calculator = getattr(calc_mod, 'Calculator', None)
CalculatorError = getattr(calc_mod, 'CalculatorError', ZeroDivisionError)
MainWindow = getattr(gui_mod, 'MainWindow', None)


@pytest.mark.parametrize(
    "method,a,b,expected",
    [
        ("add", 2, 3, 5),
        ("add", -1, 1.5, 0.5),
        ("subtract", 10, 4, 6),
        ("subtract", 0, 5, -5),
        ("multiply", 3, 7, 21),
        ("multiply", -2, -4, 8),
        ("divide", 10, 2, 5),
        ("divide", 7.5, 2.5, 3),
    ],
)
def test_calculator_basic_operations(method, a, b, expected):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: create Calculator instance
    assert Calculator is not None, "Calculator class must be present in module"
    calc = Calculator()

    # Act: call the requested method
    func = getattr(calc, method)
    result = func(a, b)

    # Assert: result equals expected and is numeric
    assert isinstance(result, (int, float))
    # allow small rounding differences for floats
    assert abs(result - expected) < 1e-9


def test_calculator_divide_by_zero_raises():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    assert Calculator is not None
    calc = Calculator()
    exc_type = getattr(calc_mod, 'CalculatorError', ZeroDivisionError)

    # Act / Assert: dividing by zero should raise the custom error or ZeroDivisionError
    with pytest.raises(exc_type):
        calc.divide(1, 0)


def _find_widget(instance, widget_types):
    """Helper: find first attribute on instance that is instance of any widget_types"""
    for attr_name, value in vars(instance).items():
        if isinstance(value, widget_types):
            return value
    return None


def test_mainwindow_calculate_populates_history_and_save_history(tmp_path, monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: ensure MainWindow exists and QApplication is present
    assert MainWindow is not None, "MainWindow must be present in GUI module"

    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])

    main = MainWindow()

    # Find input widgets (QLineEdit) and history widget (QListWidget/QTextEdit/QPlainTextEdit)
    input_widgets = [v for v in vars(main).values() if isinstance(v, QtWidgets.QLineEdit)]
    history_widget = _find_widget(main, (QtWidgets.QListWidget, QtWidgets.QTextEdit, QtWidgets.QPlainTextEdit))

    if not input_widgets:
        pytest.skip("No QLineEdit input widgets found on MainWindow; cannot perform calculate test")
    if history_widget is None:
        pytest.skip("No history-like widget found on MainWindow; cannot verify history population")

    # Act: populate inputs and call calculate
    # Arrange (inputs): if two inputs, treat as operand1 and operand2; else put expression into single input
    if len(input_widgets) >= 2:
        input_widgets[0].setText("8")
        input_widgets[1].setText("5")
    else:
        input_widgets[0].setText("8+5")

    # Call calculate and assert no error
    calculate = getattr(main, 'calculate', None)
    if calculate is None:
        pytest.skip("MainWindow.calculate method not present")
    calculate()

    # Assert: history widget got updated (non-empty)
    if isinstance(history_widget, QtWidgets.QListWidget):
        assert history_widget.count() > 0
    else:
        text = history_widget.toPlainText()
        assert isinstance(text, str)
        assert text.strip() != ""

    # Now test save_history creates a file and writes something
    target_file = tmp_path / "history_output.txt"
    # Monkeypatch the file dialog to return our path
    monkeypatch.setattr(QtWidgets.QFileDialog, 'getSaveFileName', lambda *args, **kwargs: (str(target_file), ''))
    save_history = getattr(main, 'save_history', None)
    if save_history is None:
        pytest.skip("MainWindow.save_history method not present")
    # Call save_history which should write to the file
    save_history()

    # Assert file exists and is non-empty
    assert target_file.exists(), "save_history should create the target file"
    assert target_file.stat().st_size > 0, "saved history file should not be empty"


def test_mainwindow_clear_input_and_clear_history(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    assert MainWindow is not None
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])

    main = MainWindow()

    # Find input widgets and history widget
    input_widgets = [v for v in vars(main).values() if isinstance(v, QtWidgets.QLineEdit)]
    history_widget = _find_widget(main, (QtWidgets.QListWidget, QtWidgets.QTextEdit, QtWidgets.QPlainTextEdit))

    if not input_widgets:
        pytest.skip("No QLineEdit input widgets to test clearing behavior")
    if history_widget is None:
        pytest.skip("No history-like widget to test clearing behavior")

    # Populate inputs and history
    for idx, w in enumerate(input_widgets):
        w.setText(f"test{idx}")
        assert w.text() != ""  # sanity

    # Add one entry to history (depending on widget type)
    if isinstance(history_widget, QtWidgets.QListWidget):
        history_widget.addItem("entry1")
        assert history_widget.count() > 0
    else:
        history_widget.setPlainText("entry1")
        assert history_widget.toPlainText().strip() != ""

    # Act: call clear_input and clear_history
    clear_input = getattr(main, 'clear_input', None)
    if clear_input is None:
        pytest.skip("MainWindow.clear_input method not present")
    clear_input()

    # Assert input widgets cleared
    for w in input_widgets:
        assert w.text() == ""

    clear_history = getattr(main, 'clear_history', None)
    if clear_history is None:
        pytest.skip("MainWindow.clear_history method not present")
    clear_history()

    # Assert history cleared
    if isinstance(history_widget, QtWidgets.QListWidget):
        assert history_widget.count() == 0
    else:
        assert history_widget.toPlainText().strip() == ""
