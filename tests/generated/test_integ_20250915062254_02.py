
# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT")
if _target and os.path.isdir(_target):
    if _target not in sys.path: sys.path.insert(0, _target)

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

# Optional Django bootstrap to avoid masking real failures by default.
if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

import os
os.environ.setdefault('QT_QPA_PLATFORM', 'offscreen')
for __qt_root in ['PyQt5','PyQt6','PySide2','PySide6']:
    try:
        import importlib.util as _iu
        if _iu.find_spec(__qt_root) is None:
            raise ImportError
    except Exception:
        pass
# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

import builtins
import types
import pytest

try:
    import PyQt5  # third-party dependency used by the UI module
except ImportError:
    pytest.skip("PyQt5 is required for these integration tests", allow_module_level=True)

try:
    import Calculator as calc_mod
except ImportError:
    pytest.skip("Calculator module is required for these integration tests", allow_module_level=True)

try:
    import SimpleCalculatorPyQt1 as ui_mod
except ImportError:
    pytest.skip("SimpleCalculatorPyQt1 module is required for these integration tests", allow_module_level=True)

from unittest.mock import mock_open, patch

@pytest.mark.parametrize(
    "a,b,expected",
    [
        (2, 3, 6),
        (-1, 5, -5),
        (0, 100, 0),
        (123456789, 0, 0),
        (1.5, 2, 3.0),
    ],
)
def test_2_multiply_various(a, b, expected):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange: locate multiply implementation (module function or instance method)
    multiply_fn = getattr(calc_mod, "multiply", None)
    Calculator = getattr(calc_mod, "Calculator", None)

    # Act & Assert: support either a top-level function or a method on the Calculator class
    if callable(multiply_fn):
        # Act
        result = multiply_fn(a, b)
        # Assert
        assert isinstance(result, (int, float))
        assert result == expected
    elif Calculator is not None and hasattr(Calculator, "multiply"):
        calc_instance = Calculator()
        result = calc_instance.multiply(a, b)
        assert isinstance(result, (int, float))
        assert result == expected
    else:
        pytest.skip("No multiply function or Calculator.multiply method to test")

@pytest.mark.parametrize(
    "numerator,denominator,expect_exception",
    [
        (10, 2, False),
        (5, -2, False),
        (0, 3, False),
        (1, 0, True),  # division by zero path
    ],
)
def test_3_divide_normal_and_zero(numerator, denominator, expect_exception):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    divide_fn = getattr(calc_mod, "divide", None)
    Calculator = getattr(calc_mod, "Calculator", None)
    # Preferred custom exception if present, otherwise use ZeroDivisionError
    CalcErr = getattr(calc_mod, "CalculatorError", ZeroDivisionError)

    # Act & Assert
    if callable(divide_fn):
        if expect_exception:
            with pytest.raises(CalcErr):
                divide_fn(numerator, denominator)
        else:
            result = divide_fn(numerator, denominator)
            assert isinstance(result, (int, float))
            # concrete value check
            assert result == pytest.approx(numerator / denominator)
    elif Calculator is not None and hasattr(Calculator, "divide"):
        calc_instance = Calculator()
        if expect_exception:
            with pytest.raises(CalcErr):
                calc_instance.divide(numerator, denominator)
        else:
            result = calc_instance.divide(numerator, denominator)
            assert isinstance(result, (int, float))
            assert result == pytest.approx(numerator / denominator)
    else:
        pytest.skip("No divide function or Calculator.divide method to test")

def _get_save_history_callable_and_container():
    """
    Helper to locate a save_history callable and an object that provides the history.
    Returns (callable, container, expects_filename_bool)
    - callable: function or function descriptor (for methods)
    - container: if callable is module-level, container is ui_mod; if method, container is a fake instance
    - expects_filename_bool: True if calling with a filename is likely supported (heuristic)
    """
    save_fn = getattr(ui_mod, "save_history", None)
    if callable(save_fn):
        # module-level function; it may accept a filename or use global state
        # prefer to supply a filename, but caller may raise TypeError which caller will handle
        # Try to prepare module-level history if present
        if not hasattr(ui_mod, "history"):
            # create a module-level history attribute to be used by save_history
            ui_mod.history = []
        return save_fn, ui_mod, True

    MainWindow = getattr(ui_mod, "MainWindow", None)
    if MainWindow is None:
        return None, None, False

    # get unbound function (descriptor)
    method = getattr(MainWindow, "save_history", None)
    if method is None:
        return None, None, False

    # Create a lightweight fake instance that has the attributes save_history is likely to use
    fake = types.SimpleNamespace()
    # common attribute used by the UI for history is often 'history' (a list of strings)
    fake.history = []
    # Some implementations might expect a QTextEdit or QListWidget; to be resilient, provide a .toPlainText / .text method
    fake.history_widget = None
    return method, fake, True

def _call_save_history(callable_obj, container, filename=None):
    """
    Attempt to call save_history in flexible ways:
    - If callable_obj is an unbound method (descriptor), call with container as self.
    - First attempt to pass filename if provided; if TypeError, retry without filename.
    """
    # Determine if callable_obj expects a bound self: check if it's a function defined on a class by inspecting __qualname__
    is_method = hasattr(callable_obj, "__qualname__") and "." in callable_obj.__qualname__
    # Try calling with filename first if provided
    if filename is not None:
        try:
            if is_method:
                return callable_obj(container, filename)
            else:
                return callable_obj(filename)
        except TypeError:
            # Fallback to calling without filename
            if is_method:
                return callable_obj(container)
            else:
                return callable_obj()
    else:
        if is_method:
            return callable_obj(container)
        else:
            return callable_obj()

def test_4_save_history_writes_file(tmp_path):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    callable_obj, container, expects_filename = _get_save_history_callable_and_container()
    if callable_obj is None:
        pytest.skip("No save_history function or MainWindow.save_history method available to test")
    # prepare non-empty history
    sample_entries = ["2 * 3 = 6", "10 / 2 = 5"]
    # Try to set history in the container (module or fake instance)
    if hasattr(container, "history"):
        container.history = list(sample_entries)
    else:
        # fallback: set an attribute that save_history might inspect
        setattr(container, "history", list(sample_entries))

    filepath = tmp_path / "history.txt"
    m_open = mock_open()

    # Act
    with patch("builtins.open", m_open):
        try:
            if expects_filename:
                _call_save_history(callable_obj, container, str(filepath))
            else:
                _call_save_history(callable_obj, container, None)
        except TypeError:
            pytest.skip("save_history callable signature not supported for test invocation")

    # Assert: file was attempted to be opened for writing and content contains first entry
    m_open.assert_called()
    handle = m_open()
    # At least one write call should have happened for non-empty history
    assert handle.write.call_count >= 1
    written_data = "".join(call_args[0][0] for call_args in handle.write.call_args_list)
    assert sample_entries[0] in written_data

def test_5_save_history_empty_history_creates_or_leaves_empty_file(tmp_path):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    callable_obj, container, expects_filename = _get_save_history_callable_and_container()
    if callable_obj is None:
        pytest.skip("No save_history function or MainWindow.save_history method available to test")
    # prepare empty history
    if hasattr(container, "history"):
        container.history = []
    else:
        setattr(container, "history", [])

    filepath = tmp_path / "history_empty.txt"
    m_open = mock_open()

    # Act
    with patch("builtins.open", m_open):
        try:
            if expects_filename:
                _call_save_history(callable_obj, container, str(filepath))
            else:
                _call_save_history(callable_obj, container, None)
        except TypeError:
            pytest.skip("save_history callable signature not supported for test invocation")

    # Assert: file open attempted; for empty history many implementations will not write any data,
    # so allow write count of 0, but ensure open was used to create/truncate the file.
    m_open.assert_called()
    handle = m_open()
    # Concrete assertion: empty history should not produce writing of sample content
    assert handle.write.call_count in (0, 1)  # accept either no writes or a single newline/write
    if handle.write.call_count == 1:
        written_data = handle.write.call_args[0][0]
        assert written_data == "" or written_data.isspace()  # if something was written, it should be empty/whitespace only
