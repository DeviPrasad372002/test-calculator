
# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT")
if _target and os.path.isdir(_target):
    if _target not in sys.path: sys.path.insert(0, _target)

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

# Optional Django bootstrap to avoid masking real failures by default.
if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

import os
os.environ.setdefault('QT_QPA_PLATFORM', 'offscreen')
for __qt_root in ['PyQt5','PyQt6','PySide2','PySide6']:
    try:
        import importlib.util as _iu
        if _iu.find_spec(__qt_root) is None:
            raise ImportError
    except Exception:
        pass
# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

try:
    import pytest
except ImportError:  # pragma: no cover - ensures test suite environment has pytest
    raise

# Ensure the core Calculator module is available; if not, skip the whole test module.
try:
    import Calculator as calculator_mod
except Exception:  # broad except to catch ImportError and other import-time errors
    pytest.skip("Calculator module not available; skipping tests that require it", allow_module_level=True)

# Try to import the UI module and PyQt5; if unavailable, UI-specific tests will be skipped at runtime.
try:
    import SimpleCalculatorPyQt1 as ui_mod
    try:
        from PyQt5 import QtWidgets  # noqa: F401
        QT_AVAILABLE = True
    except Exception:
        QT_AVAILABLE = False
except Exception:
    ui_mod = None
    QT_AVAILABLE = False

from types import SimpleNamespace
from unittest import mock


@pytest.mark.parametrize(
    "func_name,a,b,expected",
    [
        ("add", 1, 2, 3),
        ("add", -1, 1, 0),
        ("add", 2.5, 0.5, 3.0),
        ("subtract", 5, 2, 3),
        ("subtract", 0, 5, -5),
        ("multiply", 3, 4, 12),
        ("multiply", -2, -3, 6),
        ("divide", 10, 2, 5),
        ("divide", 7.5, 2.5, 3.0),
    ],
)
def test_calculator_module_and_class_operations(func_name, a, b, expected):
    # Arrange-Act-Assert: generated by ai-testgen
    """
    Arrange: obtain function from module and method from Calculator instance if available.
    Act: call both implementations.
    Assert: concrete numeric results and types.
    """
    # Arrange
    func = getattr(calculator_mod, func_name, None)
    if func is None:
        pytest.skip(f"Calculator.{func_name} function not present in module")

    CalculatorClass = getattr(calculator_mod, "Calculator", None)
    calc_instance = None
    if CalculatorClass is not None:
        calc_instance = CalculatorClass()

    # Act
    result_func = func(a, b)

    # Assert for module-level function
    assert isinstance(result_func, (int, float)), "module-level operation must return numeric type"
    # Use exact equality for integers and exact floats provided by inputs
    assert result_func == expected

    # If class exists, test its method
    if calc_instance is not None:
        method = getattr(calc_instance, func_name, None)
        if method is None:
            pytest.skip(f"Calculator class missing method '{func_name}'")
        result_method = method(a, b)
        assert isinstance(result_method, (int, float))
        assert result_method == expected


def test_divide_by_zero_raises_calculatorerror_for_function_and_method():
    # Arrange-Act-Assert: generated by ai-testgen
    """
    Arrange: determine the CalculatorError type, the divide function, and Calculator.divide method.
    Act/Assert: both module function and class method raise the appropriate exception when dividing by zero.
    """
    # Arrange
    CalculatorError = getattr(calculator_mod, "CalculatorError", ZeroDivisionError)
    divide_func = getattr(calculator_mod, "divide", None)
    CalculatorClass = getattr(calculator_mod, "Calculator", None)

    if divide_func is None:
        pytest.skip("Calculator.divide function not present in module")

    # Act & Assert for module-level function
    with pytest.raises(CalculatorError):
        divide_func(1, 0)

    # For the class method if present
    if CalculatorClass is not None:
        calc_instance = CalculatorClass()
        method = getattr(calc_instance, "divide", None)
        if method is None:
            pytest.skip("Calculator.divide method not present on Calculator class")
        with pytest.raises(CalculatorError):
            method(5, 0)


@pytest.mark.skipif(not QT_AVAILABLE or ui_mod is None, reason="PyQt5 or UI module unavailable; skipping UI tests")
def test_mainwindow_api_and_clear_input_and_history(tmp_path, monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    """
    Arrange: create a QApplication and MainWindow, then exercise clear_input and clear_history.
    This test is defensive: it searches for likely widget attributes and validates state changes.
    """
    # Arrange
    # Create a QApplication instance if one does not exist
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])

    MainWindowClass = getattr(ui_mod, "MainWindow", None)
    if MainWindowClass is None:
        pytest.skip("MainWindow class not present in UI module")

    # Instantiate the main window
    mw = MainWindowClass()

    # Helper to find an input-like widget: QLineEdit or any object with setText/getText/text methods
    def find_input_like(obj):
        candidates = []
        for name in dir(obj):
            if name.startswith("_"):
                continue
            try:
                attr = getattr(obj, name)
            except Exception:
                continue
            # Look for typical line edit or similar
            if hasattr(attr, "setText") and hasattr(attr, "text"):
                candidates.append((name, attr))
            # Some widgets expose toPlainText/toHtml, accept them as a fallback
            elif hasattr(attr, "setPlainText") and hasattr(attr, "toPlainText"):
                candidates.append((name, attr))
        return candidates

    input_candidates = find_input_like(mw)
    history_candidates = []
    # History may be a text widget or a simple list attribute
    for name in dir(mw):
        if name.startswith("_"):
            continue
        try:
            attr = getattr(mw, name)
        except Exception:
            continue
        if isinstance(attr, list):
            history_candidates.append((name, attr))
        elif hasattr(attr, "toPlainText") or hasattr(attr, "toHtml") or hasattr(attr, "append"):
            history_candidates.append((name, attr))

    # If no input-like widgets found, we still assert presence of API methods
    assert hasattr(mw, "clear_input"), "MainWindow should expose clear_input"
    assert hasattr(mw, "clear_history"), "MainWindow should expose clear_history"
    assert hasattr(mw, "save_history"), "MainWindow should expose save_history"
    assert callable(getattr(mw, "calculate", None)), "MainWindow should expose a callable calculate()"

    # Act & Assert for clear_input when an input widget is present
    if input_candidates:
        name, widget = input_candidates[0]
        # Arrange - set some non-empty value
        if hasattr(widget, "setText"):
            widget.setText("42")
            assert widget.text() != ""
        elif hasattr(widget, "setPlainText"):
            widget.setPlainText("42")
            assert widget.toPlainText() != ""
        # Act
        mw.clear_input()
        # Assert cleared
        if hasattr(widget, "text"):
            assert widget.text() == "" or widget.text() == "0"
        elif hasattr(widget, "toPlainText"):
            assert widget.toPlainText() == "" or widget.toPlainText() == "0"

    # Act & Assert for clear_history when a history-like attribute is present
    if history_candidates:
        name, hist = history_candidates[0]
        # Arrange - set some non-empty history
        if isinstance(hist, list):
            hist.append("one")
            hist.append("two")
            assert len(hist) >= 2
        elif hasattr(hist, "append"):
            # e.g., QTextEdit-like with append method
            hist.append("one")
            # For QTextEdit, append may accept a string; we cannot reliably read back content,
            # but we ensure method exists and does not raise on append during setup.
        # Act
        mw.clear_history()
        # Assert cleared for known types
        if isinstance(hist, list):
            assert len(hist) == 0
        elif hasattr(hist, "toPlainText"):
            assert hist.toPlainText() == "" or hist.toPlainText() == "0"


@pytest.mark.skipif(not QT_AVAILABLE or ui_mod is None, reason="PyQt5 or UI module unavailable; skipping UI tests")
def test_save_history_writes_file_using_monkeypatched_open(tmp_path, monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    """
    Arrange: ensure MainWindow.save_history invokes file write. We monkeypatch builtins.open
    to capture writes without depending on internal widget structure.
    Act: call save_history with a target path.
    Assert: that open was called for writing and that write was called with some content.
    """
    MainWindowClass = getattr(ui_mod, "MainWindow", None)
    if MainWindowClass is None:
        pytest.skip("MainWindow class not present in UI module")

    mw = MainWindowClass()

    target_file = tmp_path / "history.txt"
    wrote = {"called": False, "data": b""}

    # Create a fake file object to capture writes
    class DummyFile:
        def __init__(self, path, mode="w", *args, **kwargs):
            self._buffer = bytearray()
            self.mode = mode

        def write(self, data):
            # capture both str and bytes
            if isinstance(data, str):
                wrote["data"] += data.encode("utf-8")
            else:
                wrote["data"] += bytes(data)
            wrote["called"] = True
            return len(data)

        def writelines(self, lines):
            for line in lines:
                self.write(line)

        def __enter__(self):
            return self

        def __exit__(self, exc_type, exc_val, exc_tb):
            return False

    # Monkeypatch builtins.open used by save_history
    monkeypatch.setattr("builtins.open", lambda path, mode="w", *args, **kwargs: DummyFile(path, mode), raising=False)

    # Some implementations of save_history may attempt to read from an attribute like self.history or from a widget.
    # To maximize coverage, attempt to set a few likely attributes so save_history can find content to write.
    for poss in ("history", "historyText", "textBrowser", "history_widget"):
        if not hasattr(mw, poss):
            try:
                setattr(mw, poss, "one\ntwo\n")
            except Exception:
                # skip attributes that cannot be set
                pass

    # Act
    try:
        mw.save_history(str(target_file))
    except Exception as exc:
        # If save_history is implemented but relies on other UI elements resulting in runtime errors,
        # surface the exception so the developer can fix the implementation. This keeps the test strict.
        raise

    # Assert that our monkeypatched open was used and that some data was written
    assert wrote["called"], "save_history should open the file and write history content"
