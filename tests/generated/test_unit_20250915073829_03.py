
# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]  # behave like a namespace package
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

# Optional Django bootstrap to avoid masking real failures by default.
if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

import os
os.environ.setdefault('QT_QPA_PLATFORM', 'offscreen')
for __qt_root in ['PyQt5','PyQt6','PySide2','PySide6']:
    try:
        import importlib.util as _iu
        if _iu.find_spec(__qt_root) is None:
            raise ImportError
    except Exception:
        pass
# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

import pytest
try:
    from target import SimpleCalculatorPyQt1
    from target import Calculator as CalcModule
    from PyQt5.QtWidgets import QApplication
except ImportError as e:
    pytest.skip("Required modules (PyQt5 or target modules) are not available: " + str(e), allow_module_level=True)

# Ensure a QApplication exists for any GUI code that might require it
_app = QApplication.instance()
if _app is None:
    _app = QApplication([])

class DummyField:
    def __init__(self, initial=""):
        self._text = str(initial)

    def setText(self, v):
        self._text = str(v)

    def text(self):
        return str(self._text)

    def setPlainText(self, v):
        self.setText(v)

    def toPlainText(self):
        return self.text()

    # For combo-like widgets
    def setCurrentText(self, v):
        self._text = str(v)

    def currentText(self):
        return self.text()

class DummyWindow:
    """
    Minimal flexible window substitute: any attribute access returns a DummyField unless explicitly set.
    Useful because the real MainWindow may name fields differently; tests set the specific attributes used.
    """
    def __init__(self):
        self._fields = {}

    def __getattr__(self, name):
        if name in self._fields:
            return self._fields[name]
        # create a default DummyField on first access
        f = DummyField()
        self._fields[name] = f
        return f

    def set_field(self, name, field):
        self._fields[name] = field

def test_clear_input_resets_input_and_result_fields():
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    window = DummyWindow()
    inp = DummyField("12345")
    res = DummyField("result")
    window.set_field('input', inp)
    window.set_field('result', res)

    # Act
    # Use the module-level clear_input; many implementations accept the window argument
    SimpleCalculatorPyQt1.clear_input(window)

    # Assert
    assert window.input.text() == "", "clear_input should empty the input field"
    assert window.result.text() == "", "clear_input should also clear the result display"

def test_clear_history_clears_history_file_and_gui_area(tmp_path, monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    tmp_file = tmp_path / "history.txt"
    tmp_file.write_text("old history line\n")

    # If the module uses a variable name for the history file, override it; otherwise monkeypatch attribute used
    if hasattr(SimpleCalculatorPyQt1, 'HISTORY_FILE'):
        monkeypatch.setattr(SimpleCalculatorPyQt1, 'HISTORY_FILE', str(tmp_file))
    else:
        # set a best-effort attribute
        setattr(SimpleCalculatorPyQt1, 'HISTORY_FILE', str(tmp_file))

    # Create a dummy window with a history area that supports setPlainText/toPlainText
    window = DummyWindow()
    history_widget = DummyField("some old history")
    window.set_field('history', history_widget)

    # Act
    SimpleCalculatorPyQt1.clear_history(window)

    # Assert
    # GUI cleared
    # Some implementations may use text(), others toPlainText(); check both via helper methods on DummyField
    assert window.history.text() == "" or window.history.toPlainText() == "", "clear_history should clear the GUI history area"

    # File cleared or at least not containing previous content
    if tmp_file.exists():
        content = tmp_file.read_text()
        assert content == "" or "old history" not in content, "clear_history should remove or empty the persisted history"

def test_calculate_calls_calculator_add_and_updates_result(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    window = DummyWindow()
    # Some implementations might use different attribute names; set a couple of likely ones
    a = DummyField("3")
    b = DummyField("4")
    op = DummyField("+")
    res = DummyField("")
    window.set_field('input1', a)
    window.set_field('input2', b)
    window.set_field('operator', op)
    window.set_field('result', res)
    # Ensure other common names are present too
    window.set_field('lineEdit1', a)
    window.set_field('lineEdit2', b)
    window.set_field('comboBox', op)

    # Monkeypatch the Calculator.add to return a precise string so we can assert exactly
    class StubCalculator:
        @staticmethod
        def add(x, y):
            # A production Calculator would receive numbers; return string to assert directly
            return "7"

    monkeypatch.setattr(CalcModule, 'Calculator', StubCalculator)

    # Act
    SimpleCalculatorPyQt1.calculate(window)

    # Assert
    # Many implementations will set result via setText; ensure we read via text()
    assert isinstance(window.result.text(), str)
    assert window.result.text() == "7", "calculate should display the addition result returned by Calculator.add"

def test_calculate_handles_division_by_zero_error(monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    window = DummyWindow()
    window.set_field('input1', DummyField("10"))
    window.set_field('input2', DummyField("0"))
    window.set_field('operator', DummyField("/"))
    window.set_field('result', DummyField(""))

    # Make divide raise the module-defined CalculatorError if present, otherwise ZeroDivisionError
    expected_exc = getattr(CalcModule, 'CalculatorError', ZeroDivisionError)

    class StubCalculator:
        @staticmethod
        def divide(x, y):
            raise expected_exc("division by zero simulated")

    monkeypatch.setattr(CalcModule, 'Calculator', StubCalculator)

    # Act / Assert: Accept either behavior: calculate may re-raise or handle and set an error message in the GUI.
    try:
        SimpleCalculatorPyQt1.calculate(window)
    except Exception as e:
        assert isinstance(e, expected_exc), "If calculate re-raises, it should raise the calculator-specific exception"
    else:
        # If no exception, ensure an error message was displayed to the user
        displayed = window.result.text()
        assert isinstance(displayed, str)
        assert displayed != "", "calculate should show an error message in the result when division by zero occurs"
        assert any(token in displayed.lower() for token in ("error", "divide", "zero")), "Displayed message should indicate a division/by-zero error"
