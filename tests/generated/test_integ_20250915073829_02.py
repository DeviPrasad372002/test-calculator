
# --- ENHANCED UNIVERSAL BOOTSTRAP ---
import os, sys, importlib.util as _iu, types as _types, pytest as _pytest, builtins as _builtins, warnings
STRICT = os.getenv("TESTGEN_STRICT", "1").lower() in ("1","true","yes")
STRICT_FAIL = os.getenv("TESTGEN_STRICT_FAIL","0").lower() in ("1","true","yes")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=PendingDeprecationWarning)

_target = os.environ.get("TARGET_ROOT") or os.environ.get("ANALYZE_ROOT") or "target"
if _target and os.path.isdir(_target):
    _parent = os.path.abspath(os.path.join(_target, os.pardir))
    for p in (_parent, _target):
        if p not in sys.path:
            sys.path.insert(0, p)
    if "target" not in sys.modules:
        _pkg = _types.ModuleType("target")
        _pkg.__path__ = [_target]  # behave like a namespace package
        sys.modules["target"] = _pkg

def _exc_lookup(name, default):
    try:
        mod_name, _, cls_name = str(name).rpartition(".")
        if mod_name:
            mod = __import__(mod_name, fromlist=[cls_name])
            return getattr(mod, cls_name, default)
        return getattr(sys.modules.get("builtins"), str(name), default)
    except Exception:
        return default

# Optional Django bootstrap to avoid masking real failures by default.
if os.getenv("TESTGEN_ENABLE_DJANGO_BOOTSTRAP","0") in ("1","true","yes"):
    try:
        import django
        from django.conf import settings as _dj_settings
        from django import apps as _dj_apps
        if not _dj_settings.configured:
            _cfg = dict(
                DEBUG=True, SECRET_KEY='pytest-secret',
                DATABASES={'default': {'ENGINE': 'django.db.backends.sqlite3','NAME': ':memory:'}},
                INSTALLED_APPS=['django.contrib.auth','django.contrib.contenttypes','django.contrib.sessions','django.contrib.messages'],
                MIDDLEWARE=['django.middleware.security.SecurityMiddleware','django.contrib.sessions.middleware.SessionMiddleware','django.middleware.common.CommonMiddleware'],
                USE_TZ=True, TIME_ZONE='UTC',
            )
            try: _cfg["DEFAULT_AUTO_FIELD"] = "django.db.models.AutoField"
            except Exception: pass
            try: _dj_settings.configure(**_cfg)
            except Exception: pass
        if not _dj_apps.ready:
            try: django.setup()
            except Exception: pass
        try: import django.contrib.auth.base_user as _dj_probe  # noqa
        except Exception as _e:
            _pytest.skip(f"Django core import failed safely: {_e.__class__.__name__}: {_e}", allow_module_level=True)
    except Exception as _e:
        _pytest.skip(f"Django bootstrap not available: {_e.__class__.__name__}: {_e}", allow_module_level=True)

import os
os.environ.setdefault('QT_QPA_PLATFORM', 'offscreen')
for __qt_root in ['PyQt5','PyQt6','PySide2','PySide6']:
    try:
        import importlib.util as _iu
        if _iu.find_spec(__qt_root) is None:
            raise ImportError
    except Exception:
        pass
# --- /ENHANCED UNIVERSAL BOOTSTRAP ---

try:
    import pytest
    import inspect
    import builtins
    from unittest import mock
    from types import SimpleNamespace
    import os
    import io
    try:
        import Calculator
    except ImportError:
        pytest.skip("Calculator module not available; skipping integration tests.", allow_module_level=True)
    try:
        import SimpleCalculatorPyQt1
    except ImportError:
        SimpleCalculatorPyQt1 = None
except ImportError as _e:
    # If pytest isn't available for some reason, raise so the test runner fails clearly
    raise

@pytest.mark.parametrize("a,b", [
    (3, 4),
    (0, 5),
    (-2, 3),
    (1.5, 2),
])
def test_multiply_function_and_class_method_consistency(a, b):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    multiply_func = getattr(Calculator, "multiply", None)
    CalculatorClass = getattr(Calculator, "Calculator", None)
    if multiply_func is None and (CalculatorClass is None or not hasattr(CalculatorClass, "multiply")):
        pytest.skip("No multiply function or Calculator.multiply method available")

    # Act
    results = {}
    if multiply_func is not None:
        res_func = multiply_func(a, b)
        results['func'] = res_func
    if CalculatorClass is not None and hasattr(CalculatorClass, "multiply"):
        calc = CalculatorClass()
        res_method = calc.multiply(a, b)
        results['method'] = res_method

    # Assert
    assert results, "Expected at least one multiply implementation"
    # All available results must be equal numeric values
    values = list(results.values())
    for v in values:
        assert isinstance(v, (int, float)), f"multiply returned non-numeric type: {type(v)}"
    assert all(v == values[0] for v in values), f"Inconsistent multiply implementations: {results}"

@pytest.mark.parametrize("numerator,denominator,expected", [
    (10, 2, 5),
    (7.5, 2.5, 3.0),
])
def test_divide_normal_operation_and_divide_by_zero_raises(numerator, denominator, expected):
    # Arrange-Act-Assert: generated by ai-testgen
    # Arrange
    divide_func = getattr(Calculator, "divide", None)
    CalculatorClass = getattr(Calculator, "Calculator", None)
    if divide_func is None and (CalculatorClass is None or not hasattr(CalculatorClass, "divide")):
        pytest.skip("No divide function or Calculator.divide method available")
    CalcError = getattr(Calculator, "CalculatorError", ZeroDivisionError)

    # Act & Assert - normal case
    if divide_func is not None:
        res = divide_func(numerator, denominator)
        assert isinstance(res, (int, float))
        assert res == expected
    if CalculatorClass is not None and hasattr(CalculatorClass, "divide"):
        calc = CalculatorClass()
        res2 = calc.divide(numerator, denominator)
        assert isinstance(res2, (int, float))
        assert res2 == expected

    # Act & Assert - divide by zero raises the expected exception
    if divide_func is not None:
        with pytest.raises(CalcError):
            divide_func(numerator, 0)
    if CalculatorClass is not None and hasattr(CalculatorClass, "divide"):
        calc = CalculatorClass()
        with pytest.raises(CalcError):
            calc.divide(numerator, 0)

def _try_call_save_history(save_history, path_obj, history):
    # Try a sequence of plausible call signatures for save_history.
    # Return True if one succeeds (no exception), else False.
    path_str = str(path_obj)
    candidates = [
        (path_str, history),
        (path_obj, history),
        (history, path_str),
        (history, path_obj),
    ]
    for args in candidates:
        try:
            save_history(*args)
            return True
        except TypeError:
            continue
        except Exception:
            # If save_history raises a different error (e.g., IOError), we still want to propagate it
            raise
    return False

def test_save_history_writes_expected_content(tmp_path, monkeypatch):
    # Arrange-Act-Assert: generated by ai-testgen
    # This integration test connects Calculator operations with SimpleCalculatorPyQt1.save_history
    if SimpleCalculatorPyQt1 is None:
        pytest.skip("SimpleCalculatorPyQt1 not available; skipping save_history integration test")

    save_history = getattr(SimpleCalculatorPyQt1, "save_history", None)
    MainWindow = getattr(SimpleCalculatorPyQt1, "MainWindow", None)
    if save_history is None:
        pytest.skip("save_history not found in SimpleCalculatorPyQt1")

    # Arrange
    multiply_func = getattr(Calculator, "multiply", None)
    divide_func = getattr(Calculator, "divide", None)
    if multiply_func is None or divide_func is None:
        pytest.skip("Calculator.multiply or Calculator.divide not available for building history")

    # Build a small history using the actual functions to ensure realistic content
    entries = []
    try:
        m1 = multiply_func(3, 4)
        entries.append(f"3 * 4 = {m1}")
    except ImportError as e:
        pytest.skip(f"multiply call failed unexpectedly: {e}")
    except Exception:
        raise

    try:
        d1 = divide_func(10, 2)
        entries.append(f"10 / 2 = {d1}")
    except ImportError as e:
        pytest.skip(f"divide call failed unexpectedly: {e}")
    except Exception:
        raise

    # Create target file path
    out_file = tmp_path / "history.txt"

    # Some implementations might invoke QFileDialog.getSaveFileName or other PyQt dialogs.
    # Monkeypatch common Qt file dialog functions to return our desired path if they exist.
    if hasattr(SimpleCalculatorPyQt1, "QFileDialog"):
        qfd = getattr(SimpleCalculatorPyQt1, "QFileDialog")
        if hasattr(qfd, "getSaveFileName"):
            monkeypatch.setattr(qfd, "getSaveFileName", lambda *args, **kwargs: (str(out_file), None))

    # If save_history expects a MainWindow instance, provide a minimal stand-in with attributes it might use.
    fake_window = None
    if MainWindow is not None:
        try:
            fake_window = MainWindow()
        except Exception:
            # If instantiation requires a running QApplication, provide a minimal fake object instead.
            fake_window = SimpleNamespace(history_list=entries)

    # To be robust, also patch builtins.open to ensure file writes go to the filesystem path we control
    # but allow normal behavior otherwise.
    real_open = builtins.open

    def open_side_effect(file, mode='r', *args, **kwargs):
        # Ensure relative paths end up under tmp_path for safety
        return real_open(file, mode, *args, **kwargs)

    monkeypatch.setattr(builtins, "open", open_side_effect)

    # Act
    try:
        called = False
        # Try direct calls: prefer signature (path, history), but try multiple possibilities
        try:
            # If save_history accepts (window, path) or (window,), try passing fake_window
            sig = inspect.signature(save_history)
            params = list(sig.parameters)
            if "window" in params and fake_window is not None:
                # Try common patterns with window
                try:
                    save_history(fake_window, str(out_file))
                    called = True
                except TypeError:
                    try:
                        save_history(fake_window, out_file)
                        called = True
                    except TypeError:
                        pass
            if not called:
                called = _try_call_save_history(save_history, out_file, entries)
        except ValueError:
            # Some callables may not have inspectable signatures; fall back to trial calls
            called = _try_call_save_history(save_history, out_file, entries)
    finally:
        # restore open if monkeypatch didn't do it (pytest monkeypatch will auto-restore, but keep safe)
        pass

    if not called:
        pytest.skip("Could not call save_history with any known signature; skipping")

    # Assert - file exists and contains our history lines
    assert out_file.exists(), f"Expected history file at {out_file} to exist after save_history"
    content = out_file.read_text(encoding="utf-8")
    for entry in entries:
        assert entry in content, f"Expected history entry '{entry}' in saved file content"
